One problem I've just come across is ensuring existence of
records passed into APIs. This is a common validation
task and normally it is automatically taken care of for
you, if you are doing an update operation and the primary
key for the entity is not found the update operation
will fail since the record will not be found in the
database.

Duality of Ids

In AIRport there is an additional condition that complicates
things. To <a href="AIR_UuId.html#performance">save on
    memory</a> required to store tables and
indexes in memory in the Web Version of AIRport (and
down the like app server caches) numeric ids are
used to identify all of the objects.

For AIRport clients and apps each object contains a
computed <a href="./AIR_UuId.html>">UuId field</a>. The
user is expected to stick with using UuIds and ignore
numeric ids altogether.  This will eventually lead to
user confusion and application bugs where the Users
will default to using numeric ids. Thes are the "id"
properties for Repository, Actor and User objects and
the "actorRecordId" property for all Entity objects.

Renaming Ids

To reduce user confusion the "id" field is now
renamed to "_local_relation_key".  This accurately
describes the purpose of this field - it is there to
link records together in the local database (often
in memory).  The name also doesn't immediately stand
out as an identifer to be used as and identifier. The
"actorRecordId" is also now renamed to be
"_local_relation_actor_record_key".

To make things completely clear the "uuId" field
is now renamed to be "id".  It always is the unique
identifier for all Entity records and naming it id
clearly indicates to the user that it is what should
be used as the identifier.  Keeping the "uu" qualifier
can put doubt into developers mind: "Am I using the
right id"?

Checking Entity Existence

The renaming "uuId" to just "id" also clarifies the
situation on how existence of records is done -
database should just take care of that.  And this
is exactly how AIRport now behaves at the cost of
some additional querying operations:

AIRport now creates in-memory caches at the top
level transaction, with all nested transactions reusing
this cache.  In this cache all objects present in the
"save" object graphs are kept.  For every "save"
operation AIRport does a pre-scan of the entire passed
in graph and generates lists of existing objects.  One
list for each object type.  Once the lists are
created AIRport queries for those objects by the
composite unique idenfiier ids and replaced the passed
in local ids with ids that match the local ids.  Then
it places all of the found objects in the object cache
and performs the persistence operations.

The id cache is then reused all other "save" operations
included with the top level transaction, including
all nested transactions caused by nested @Api() calls.
This should be particularily useful for checking
Repository, Actor and User records since the same objects
are very likely to be used throughout the top level
transaction.

The object cache is maintained during the transaction by
removing objects that have been deleted during the
transaction.  And the cache is released after the top
level transaction completes.
